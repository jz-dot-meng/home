<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><meta charSet="utf-8"/><link rel="icon" href="/icons/favicon.png"/><meta name="theme-color" content="#000000"/><meta name="description" content="a selection of personal projects"/><link rel="apple-touch-icon" href="/icons/favicon.png"/><meta property="og:url" content="https://jz-dot-meng.github.io"/><meta property="og:title" content="@jz-dot-meng"/><meta property="og:description" content="a selection of personal projects"/><meta property="og:image" content="/icons/favicon.png"/><link rel="preload" href="./_next/static/css/b1afebe894815190.css" as="style"/><link rel="stylesheet" href="./_next/static/css/b1afebe894815190.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="./_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="./_next/static/chunks/webpack-e50e9853db18b759.js" defer=""></script><script src="./_next/static/chunks/framework-af64bd368ed34feb.js" defer=""></script><script src="./_next/static/chunks/main-1d70268cd9043d1c.js" defer=""></script><script src="./_next/static/chunks/pages/_app-2118a43450d42b86.js" defer=""></script><script src="./_next/static/chunks/894-1fa07c886a8b7d43.js" defer=""></script><script src="./_next/static/chunks/pages/blog/post/exploring-digital-identities-a-plan-4ae64f3f52c98fbd.js" defer=""></script><script src="./_next/static/pP3tNxfDU17keumD9yPC9/_buildManifest.js" defer=""></script><script src="./_next/static/pP3tNxfDU17keumD9yPC9/_ssgManifest.js" defer=""></script></head><meta name="viewport" content="width=device-width, initial-scale=1"/><title>@jz-dot-meng</title><body class="bg-black-900 text-white h-screen overflow-hidden"><div id="__next"><div class="Toastify"></div><div class="flex justify-center h-full p-8 overflow-y-scroll no-scrollbar"><div class="flex flex-col gap-2"><section class="flex flex-col gap-4"><h4><a href="/">@jz-dot-meng</a></h4><div class="flex items-start flex-col gap-1 md:items-end md:flex-row"><h1>exploring digital identities - a plan</h1><span class="pb-2"> :: <!-- -->creating an online social space</span></div><div class="text-xs md:text-sm flex flex-col gap-1"><p>first drafted: <!-- -->Thu May 25 2023</p></div><div><span class="text-grey-600 text-xs">tags:</span> <span><a href="/blog">project</a></span></div></section><section class="py-8 flex flex-col gap-4"><i>This post serves as both a preamble and outline of a three-part plan, and a means to hold myself accountable for executing on said plan. Given that I work full-time as a freelance/contractor software dev, I&#x27;ll allow myself the concession of not setting concrete timeframes, but here goes:</i><p>Recently I have been reading and watching a lot of videos about<!-- --> <a target="_blank" href="https://www.youtube.com/watch?v=RCJdPiogUIk">hacking</a>,<!-- --> <a target="_blank" href="https://github.com/0xJuancito/multichain-auditor">penetration testing/security auditing</a> <!-- -->and<!-- --> <a target="_blank" href="https://salt.security/blog/a-new-oauth-vulnerability-that-may-impact-hundreds-of-online-services">post-hack vulnerability breakdowns</a>. This interest was born from the &#x27;hacker&#x27;-esque mindset embraced by the current startup that I&#x27;m working at, fostered by the genius whizz of a software dev that I count lucky to call my colleague - as part of the &#x27;build fast, iterate better&#x27; mentality, there&#x27;s a lot of reverse-engineering API calls, and scraping off services that don&#x27;t secure their database behind (standard?) security protocols (so we don&#x27;t need to devote dev time to roll our own modules and infrastructure in order to manually index the same publicly-available data, not for nefarious reasons!).</p><p>Tangentially, this has also meant touching on cryptography, and trying to understand (at least on a surface level, if not more in depth) for example the steps involved from start to end how your computer reaches out to a server, and how the two<!-- --> <a href="https://tls13.xargs.org/#client-key-exchange-generation">complete a handshake</a> <!-- -->to generate a shared key with which data can be encrypted on one end and decrypted on the other.</p><p>This led to the following idea - what better way to learn more about the processes involved, than to build something of my own that implements it? Now I know, the first rule (if there were any) in the cryptography community is for non-specialists to NOT run their own implementation of existing cryptographic protocols, which makes complete sense! And so where ever possible, I&#x27;ll seek to use open source cryptography libraries, and also make very apparent that this is something I&#x27;ve built on my own, mainly for learning and novelty purposes, and not intended for anything secure.</p><p>That being said, here&#x27;s the plan:</p><h2>part 1: pseudonymous identities</h2><i>goal: allow visitors to the site to generate a pseudonymous identity</i><p>brief: visitors will be able opt in to creating + registering a pseudonymous identity, which will allow them to leave music suggestions on my<!-- --> <a href="/music/recently-listened">music page</a>, drop their high score on a leaderboard on each of my <a href="/minigame/memory">minigames</a>, and maybe even leave comments on these blog posts.</p><p>technical: there&#x27;ll be no need to sign-in to any third party service (Facebook, Google, etc.) - a private key will be generated for the public identity, and will be stored in the web browser&#x27;s local storage, with the option to export (should anyone feel strongly enough to maintain the same identity across different browsers/devices). Storage of public identifiers, leaderboard and comments/suggestions in plain-text will initially be Google&#x27;s<!-- --> <a href="https://firebase.google.com/">Firebase</a>, simply because I am familiar with the workflow to be able to get something up and running quickly</p><h2>part 2: private messaging</h2><i>goal: allow two visitors to instantiate a private messaging channel</i><p>brief: a registered identity can view other registered identities on this site, and request to connect with one to exchange private messages. on a semi-technical note, these messages will be stored in its encrypted form in Firebase storage, and should only be able to be decrypted locally in-browser by the two identities via their private keys.</p><p>tehcnical: a whole lot more research on my part needs to go into this: I only understand on a high level how ECDH works<!-- --> <i>just so two users can agree on a shared key</i>, without even considering how to use that shared key to encrypt messages. The idea is that the server (and any other malicious actors listening in) can see the two public identities and see the shared key they agreed on, but without the private key shouldn&#x27;t be able to do much with that information to reveal the messages themselves, since it would be computationally &#x27;impossible&#x27; to decrypt them through brute force. Of course, other information can be leaked (i.e. time when the user sends the message, message length maybe?), but at this moment it&#x27;s beyond the scope of what I&#x27;m looking to achieve.</p><h2>part 3: self-hosted?</h2><i>goal: move away from a centralised store of data</i><p>brief: allow the user to self-custody their messages</p><p>technical: ??? (see <a href="https://simplex.chat/">SimpleX chat</a> as a possible implementation to draw inspiration from)</p><p>While building this out, I&#x27;ll try to be as open-source as possible with the implementation, including (if possible) the Firebase implementation, without leaking my own private API keys left and right.</p></section><footer class="text-xs pb-8"><a href="/blog">‚Üê Return to blogs</a></footer></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{}},"page":"/blog/post/exploring-digital-identities-a-plan","query":{},"buildId":"pP3tNxfDU17keumD9yPC9","assetPrefix":".","nextExport":true,"autoExport":true,"isFallback":false,"scriptLoader":[]}</script></body></html>